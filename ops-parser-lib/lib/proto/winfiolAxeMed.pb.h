// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: winfiolAxeMed.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_winfiolAxeMed_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_winfiolAxeMed_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_winfiolAxeMed_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_winfiolAxeMed_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_winfiolAxeMed_2eproto;
namespace winfiolAxeMed {
class CommandRequest;
class CommandRequestDefaultTypeInternal;
extern CommandRequestDefaultTypeInternal _CommandRequest_default_instance_;
class CommandResponse;
class CommandResponseDefaultTypeInternal;
extern CommandResponseDefaultTypeInternal _CommandResponse_default_instance_;
class ConnectRequest;
class ConnectRequestDefaultTypeInternal;
extern ConnectRequestDefaultTypeInternal _ConnectRequest_default_instance_;
class GenericRequest;
class GenericRequestDefaultTypeInternal;
extern GenericRequestDefaultTypeInternal _GenericRequest_default_instance_;
class GenericResponse;
class GenericResponseDefaultTypeInternal;
extern GenericResponseDefaultTypeInternal _GenericResponse_default_instance_;
class SessionRequest;
class SessionRequestDefaultTypeInternal;
extern SessionRequestDefaultTypeInternal _SessionRequest_default_instance_;
class SessionResponse;
class SessionResponseDefaultTypeInternal;
extern SessionResponseDefaultTypeInternal _SessionResponse_default_instance_;
class StreamMessage;
class StreamMessageDefaultTypeInternal;
extern StreamMessageDefaultTypeInternal _StreamMessage_default_instance_;
class TerminalActionRequest;
class TerminalActionRequestDefaultTypeInternal;
extern TerminalActionRequestDefaultTypeInternal _TerminalActionRequest_default_instance_;
}  // namespace winfiolAxeMed
PROTOBUF_NAMESPACE_OPEN
template<> ::winfiolAxeMed::CommandRequest* Arena::CreateMaybeMessage<::winfiolAxeMed::CommandRequest>(Arena*);
template<> ::winfiolAxeMed::CommandResponse* Arena::CreateMaybeMessage<::winfiolAxeMed::CommandResponse>(Arena*);
template<> ::winfiolAxeMed::ConnectRequest* Arena::CreateMaybeMessage<::winfiolAxeMed::ConnectRequest>(Arena*);
template<> ::winfiolAxeMed::GenericRequest* Arena::CreateMaybeMessage<::winfiolAxeMed::GenericRequest>(Arena*);
template<> ::winfiolAxeMed::GenericResponse* Arena::CreateMaybeMessage<::winfiolAxeMed::GenericResponse>(Arena*);
template<> ::winfiolAxeMed::SessionRequest* Arena::CreateMaybeMessage<::winfiolAxeMed::SessionRequest>(Arena*);
template<> ::winfiolAxeMed::SessionResponse* Arena::CreateMaybeMessage<::winfiolAxeMed::SessionResponse>(Arena*);
template<> ::winfiolAxeMed::StreamMessage* Arena::CreateMaybeMessage<::winfiolAxeMed::StreamMessage>(Arena*);
template<> ::winfiolAxeMed::TerminalActionRequest* Arena::CreateMaybeMessage<::winfiolAxeMed::TerminalActionRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace winfiolAxeMed {

enum ConnectRequest_ApNodeSide : int {
  ConnectRequest_ApNodeSide_CLUSTER = 0,
  ConnectRequest_ApNodeSide_NODE_A = 1,
  ConnectRequest_ApNodeSide_NODE_B = 2,
  ConnectRequest_ApNodeSide_ConnectRequest_ApNodeSide_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConnectRequest_ApNodeSide_ConnectRequest_ApNodeSide_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConnectRequest_ApNodeSide_IsValid(int value);
constexpr ConnectRequest_ApNodeSide ConnectRequest_ApNodeSide_ApNodeSide_MIN = ConnectRequest_ApNodeSide_CLUSTER;
constexpr ConnectRequest_ApNodeSide ConnectRequest_ApNodeSide_ApNodeSide_MAX = ConnectRequest_ApNodeSide_NODE_B;
constexpr int ConnectRequest_ApNodeSide_ApNodeSide_ARRAYSIZE = ConnectRequest_ApNodeSide_ApNodeSide_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectRequest_ApNodeSide_descriptor();
template<typename T>
inline const std::string& ConnectRequest_ApNodeSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectRequest_ApNodeSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectRequest_ApNodeSide_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectRequest_ApNodeSide_descriptor(), enum_t_value);
}
inline bool ConnectRequest_ApNodeSide_Parse(
    const std::string& name, ConnectRequest_ApNodeSide* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectRequest_ApNodeSide>(
    ConnectRequest_ApNodeSide_descriptor(), name, value);
}
enum ConnectRequest_ApNode : int {
  ConnectRequest_ApNode_AP1 = 0,
  ConnectRequest_ApNode_AP2 = 1,
  ConnectRequest_ApNode_ConnectRequest_ApNode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConnectRequest_ApNode_ConnectRequest_ApNode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConnectRequest_ApNode_IsValid(int value);
constexpr ConnectRequest_ApNode ConnectRequest_ApNode_ApNode_MIN = ConnectRequest_ApNode_AP1;
constexpr ConnectRequest_ApNode ConnectRequest_ApNode_ApNode_MAX = ConnectRequest_ApNode_AP2;
constexpr int ConnectRequest_ApNode_ApNode_ARRAYSIZE = ConnectRequest_ApNode_ApNode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectRequest_ApNode_descriptor();
template<typename T>
inline const std::string& ConnectRequest_ApNode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectRequest_ApNode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectRequest_ApNode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectRequest_ApNode_descriptor(), enum_t_value);
}
inline bool ConnectRequest_ApNode_Parse(
    const std::string& name, ConnectRequest_ApNode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectRequest_ApNode>(
    ConnectRequest_ApNode_descriptor(), name, value);
}
enum StreamMessage_MessageType : int {
  StreamMessage_MessageType_CONTROL = 0,
  StreamMessage_MessageType_CMD_OUTPUT = 1,
  StreamMessage_MessageType_StreamMessage_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMessage_MessageType_StreamMessage_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMessage_MessageType_IsValid(int value);
constexpr StreamMessage_MessageType StreamMessage_MessageType_MessageType_MIN = StreamMessage_MessageType_CONTROL;
constexpr StreamMessage_MessageType StreamMessage_MessageType_MessageType_MAX = StreamMessage_MessageType_CMD_OUTPUT;
constexpr int StreamMessage_MessageType_MessageType_ARRAYSIZE = StreamMessage_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMessage_MessageType_descriptor();
template<typename T>
inline const std::string& StreamMessage_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMessage_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMessage_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMessage_MessageType_descriptor(), enum_t_value);
}
inline bool StreamMessage_MessageType_Parse(
    const std::string& name, StreamMessage_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMessage_MessageType>(
    StreamMessage_MessageType_descriptor(), name, value);
}
enum TerminalActionRequest_TerminalAction : int {
  TerminalActionRequest_TerminalAction_RELEASE = 0,
  TerminalActionRequest_TerminalAction_CONNECT = 1,
  TerminalActionRequest_TerminalAction_TerminalActionRequest_TerminalAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TerminalActionRequest_TerminalAction_TerminalActionRequest_TerminalAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TerminalActionRequest_TerminalAction_IsValid(int value);
constexpr TerminalActionRequest_TerminalAction TerminalActionRequest_TerminalAction_TerminalAction_MIN = TerminalActionRequest_TerminalAction_RELEASE;
constexpr TerminalActionRequest_TerminalAction TerminalActionRequest_TerminalAction_TerminalAction_MAX = TerminalActionRequest_TerminalAction_CONNECT;
constexpr int TerminalActionRequest_TerminalAction_TerminalAction_ARRAYSIZE = TerminalActionRequest_TerminalAction_TerminalAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TerminalActionRequest_TerminalAction_descriptor();
template<typename T>
inline const std::string& TerminalActionRequest_TerminalAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TerminalActionRequest_TerminalAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TerminalActionRequest_TerminalAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TerminalActionRequest_TerminalAction_descriptor(), enum_t_value);
}
inline bool TerminalActionRequest_TerminalAction_Parse(
    const std::string& name, TerminalActionRequest_TerminalAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TerminalActionRequest_TerminalAction>(
    TerminalActionRequest_TerminalAction_descriptor(), name, value);
}
// ===================================================================

class SessionRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.SessionRequest) */ {
 public:
  SessionRequest();
  virtual ~SessionRequest();

  SessionRequest(const SessionRequest& from);
  SessionRequest(SessionRequest&& from) noexcept
    : SessionRequest() {
    *this = ::std::move(from);
  }

  inline SessionRequest& operator=(const SessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionRequest& operator=(SessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionRequest* internal_default_instance() {
    return reinterpret_cast<const SessionRequest*>(
               &_SessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SessionRequest& a, SessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionRequest* New() const final {
    return CreateMaybeMessage<SessionRequest>(nullptr);
  }

  SessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionRequest& from);
  void MergeFrom(const SessionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.SessionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kEnmUserIdFieldNumber = 2,
  };
  // string clientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  void set_clientname(const std::string& value);
  void set_clientname(std::string&& value);
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  std::string* mutable_clientname();
  std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);

  // string enmUserId = 2;
  void clear_enmuserid();
  const std::string& enmuserid() const;
  void set_enmuserid(const std::string& value);
  void set_enmuserid(std::string&& value);
  void set_enmuserid(const char* value);
  void set_enmuserid(const char* value, size_t size);
  std::string* mutable_enmuserid();
  std::string* release_enmuserid();
  void set_allocated_enmuserid(std::string* enmuserid);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.SessionRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enmuserid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class SessionResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.SessionResponse) */ {
 public:
  SessionResponse();
  virtual ~SessionResponse();

  SessionResponse(const SessionResponse& from);
  SessionResponse(SessionResponse&& from) noexcept
    : SessionResponse() {
    *this = ::std::move(from);
  }

  inline SessionResponse& operator=(const SessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionResponse& operator=(SessionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionResponse* internal_default_instance() {
    return reinterpret_cast<const SessionResponse*>(
               &_SessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SessionResponse& a, SessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SessionResponse* New() const final {
    return CreateMaybeMessage<SessionResponse>(nullptr);
  }

  SessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SessionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SessionResponse& from);
  void MergeFrom(const SessionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.SessionResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.SessionResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class ConnectRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.ConnectRequest) */ {
 public:
  ConnectRequest();
  virtual ~ConnectRequest();

  ConnectRequest(const ConnectRequest& from);
  ConnectRequest(ConnectRequest&& from) noexcept
    : ConnectRequest() {
    *this = ::std::move(from);
  }

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRequest& operator=(ConnectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectRequest*>(
               &_ConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConnectRequest& a, ConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectRequest* New() const final {
    return CreateMaybeMessage<ConnectRequest>(nullptr);
  }

  ConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectRequest& from);
  void MergeFrom(const ConnectRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.ConnectRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ConnectRequest_ApNodeSide ApNodeSide;
  static constexpr ApNodeSide CLUSTER =
    ConnectRequest_ApNodeSide_CLUSTER;
  static constexpr ApNodeSide NODE_A =
    ConnectRequest_ApNodeSide_NODE_A;
  static constexpr ApNodeSide NODE_B =
    ConnectRequest_ApNodeSide_NODE_B;
  static inline bool ApNodeSide_IsValid(int value) {
    return ConnectRequest_ApNodeSide_IsValid(value);
  }
  static constexpr ApNodeSide ApNodeSide_MIN =
    ConnectRequest_ApNodeSide_ApNodeSide_MIN;
  static constexpr ApNodeSide ApNodeSide_MAX =
    ConnectRequest_ApNodeSide_ApNodeSide_MAX;
  static constexpr int ApNodeSide_ARRAYSIZE =
    ConnectRequest_ApNodeSide_ApNodeSide_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ApNodeSide_descriptor() {
    return ConnectRequest_ApNodeSide_descriptor();
  }
  template<typename T>
  static inline const std::string& ApNodeSide_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ApNodeSide>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ApNodeSide_Name.");
    return ConnectRequest_ApNodeSide_Name(enum_t_value);
  }
  static inline bool ApNodeSide_Parse(const std::string& name,
      ApNodeSide* value) {
    return ConnectRequest_ApNodeSide_Parse(name, value);
  }

  typedef ConnectRequest_ApNode ApNode;
  static constexpr ApNode AP1 =
    ConnectRequest_ApNode_AP1;
  static constexpr ApNode AP2 =
    ConnectRequest_ApNode_AP2;
  static inline bool ApNode_IsValid(int value) {
    return ConnectRequest_ApNode_IsValid(value);
  }
  static constexpr ApNode ApNode_MIN =
    ConnectRequest_ApNode_ApNode_MIN;
  static constexpr ApNode ApNode_MAX =
    ConnectRequest_ApNode_ApNode_MAX;
  static constexpr int ApNode_ARRAYSIZE =
    ConnectRequest_ApNode_ApNode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ApNode_descriptor() {
    return ConnectRequest_ApNode_descriptor();
  }
  template<typename T>
  static inline const std::string& ApNode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ApNode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ApNode_Name.");
    return ConnectRequest_ApNode_Name(enum_t_value);
  }
  static inline bool ApNode_Parse(const std::string& name,
      ApNode* value) {
    return ConnectRequest_ApNode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kNeIdFieldNumber = 2,
    kUsernameFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kNodeSideFieldNumber = 3,
    kNodeFieldNumber = 6,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // string neId = 2;
  void clear_neid();
  const std::string& neid() const;
  void set_neid(const std::string& value);
  void set_neid(std::string&& value);
  void set_neid(const char* value);
  void set_neid(const char* value, size_t size);
  std::string* mutable_neid();
  std::string* release_neid();
  void set_allocated_neid(std::string* neid);

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 5;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // .winfiolAxeMed.ConnectRequest.ApNodeSide nodeSide = 3;
  void clear_nodeside();
  ::winfiolAxeMed::ConnectRequest_ApNodeSide nodeside() const;
  void set_nodeside(::winfiolAxeMed::ConnectRequest_ApNodeSide value);

  // .winfiolAxeMed.ConnectRequest.ApNode node = 6;
  void clear_node();
  ::winfiolAxeMed::ConnectRequest_ApNode node() const;
  void set_node(::winfiolAxeMed::ConnectRequest_ApNode value);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.ConnectRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr neid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int nodeside_;
  int node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class CommandRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.CommandRequest) */ {
 public:
  CommandRequest();
  virtual ~CommandRequest();

  CommandRequest(const CommandRequest& from);
  CommandRequest(CommandRequest&& from) noexcept
    : CommandRequest() {
    *this = ::std::move(from);
  }

  inline CommandRequest& operator=(const CommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandRequest& operator=(CommandRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandRequest* internal_default_instance() {
    return reinterpret_cast<const CommandRequest*>(
               &_CommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CommandRequest& a, CommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandRequest* New() const final {
    return CreateMaybeMessage<CommandRequest>(nullptr);
  }

  CommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandRequest& from);
  void MergeFrom(const CommandRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.CommandRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kCmdInputFieldNumber = 2,
    kCmdTypeFieldNumber = 3,
    kCpNameFieldNumber = 4,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // string cmdInput = 2;
  void clear_cmdinput();
  const std::string& cmdinput() const;
  void set_cmdinput(const std::string& value);
  void set_cmdinput(std::string&& value);
  void set_cmdinput(const char* value);
  void set_cmdinput(const char* value, size_t size);
  std::string* mutable_cmdinput();
  std::string* release_cmdinput();
  void set_allocated_cmdinput(std::string* cmdinput);

  // string cmdType = 3;
  void clear_cmdtype();
  const std::string& cmdtype() const;
  void set_cmdtype(const std::string& value);
  void set_cmdtype(std::string&& value);
  void set_cmdtype(const char* value);
  void set_cmdtype(const char* value, size_t size);
  std::string* mutable_cmdtype();
  std::string* release_cmdtype();
  void set_allocated_cmdtype(std::string* cmdtype);

  // string cpName = 4;
  void clear_cpname();
  const std::string& cpname() const;
  void set_cpname(const std::string& value);
  void set_cpname(std::string&& value);
  void set_cpname(const char* value);
  void set_cpname(const char* value, size_t size);
  std::string* mutable_cpname();
  std::string* release_cpname();
  void set_allocated_cpname(std::string* cpname);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.CommandRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmdinput_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmdtype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class CommandResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.CommandResponse) */ {
 public:
  CommandResponse();
  virtual ~CommandResponse();

  CommandResponse(const CommandResponse& from);
  CommandResponse(CommandResponse&& from) noexcept
    : CommandResponse() {
    *this = ::std::move(from);
  }

  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandResponse& operator=(CommandResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandResponse* internal_default_instance() {
    return reinterpret_cast<const CommandResponse*>(
               &_CommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CommandResponse& a, CommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandResponse* New() const final {
    return CreateMaybeMessage<CommandResponse>(nullptr);
  }

  CommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandResponse& from);
  void MergeFrom(const CommandResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.CommandResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdOutputFieldNumber = 1,
  };
  // string cmdOutput = 1;
  void clear_cmdoutput();
  const std::string& cmdoutput() const;
  void set_cmdoutput(const std::string& value);
  void set_cmdoutput(std::string&& value);
  void set_cmdoutput(const char* value);
  void set_cmdoutput(const char* value, size_t size);
  std::string* mutable_cmdoutput();
  std::string* release_cmdoutput();
  void set_allocated_cmdoutput(std::string* cmdoutput);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.CommandResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmdoutput_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class StreamMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.StreamMessage) */ {
 public:
  StreamMessage();
  virtual ~StreamMessage();

  StreamMessage(const StreamMessage& from);
  StreamMessage(StreamMessage&& from) noexcept
    : StreamMessage() {
    *this = ::std::move(from);
  }

  inline StreamMessage& operator=(const StreamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMessage& operator=(StreamMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StreamMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamMessage* internal_default_instance() {
    return reinterpret_cast<const StreamMessage*>(
               &_StreamMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamMessage& a, StreamMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamMessage* New() const final {
    return CreateMaybeMessage<StreamMessage>(nullptr);
  }

  StreamMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamMessage& from);
  void MergeFrom(const StreamMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.StreamMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StreamMessage_MessageType MessageType;
  static constexpr MessageType CONTROL =
    StreamMessage_MessageType_CONTROL;
  static constexpr MessageType CMD_OUTPUT =
    StreamMessage_MessageType_CMD_OUTPUT;
  static inline bool MessageType_IsValid(int value) {
    return StreamMessage_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    StreamMessage_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    StreamMessage_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    StreamMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return StreamMessage_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return StreamMessage_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(const std::string& name,
      MessageType* value) {
    return StreamMessage_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // .winfiolAxeMed.StreamMessage.MessageType type = 2;
  void clear_type();
  ::winfiolAxeMed::StreamMessage_MessageType type() const;
  void set_type(::winfiolAxeMed::StreamMessage_MessageType value);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.StreamMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class TerminalActionRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.TerminalActionRequest) */ {
 public:
  TerminalActionRequest();
  virtual ~TerminalActionRequest();

  TerminalActionRequest(const TerminalActionRequest& from);
  TerminalActionRequest(TerminalActionRequest&& from) noexcept
    : TerminalActionRequest() {
    *this = ::std::move(from);
  }

  inline TerminalActionRequest& operator=(const TerminalActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminalActionRequest& operator=(TerminalActionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TerminalActionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TerminalActionRequest* internal_default_instance() {
    return reinterpret_cast<const TerminalActionRequest*>(
               &_TerminalActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TerminalActionRequest& a, TerminalActionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TerminalActionRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TerminalActionRequest* New() const final {
    return CreateMaybeMessage<TerminalActionRequest>(nullptr);
  }

  TerminalActionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TerminalActionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TerminalActionRequest& from);
  void MergeFrom(const TerminalActionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerminalActionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.TerminalActionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TerminalActionRequest_TerminalAction TerminalAction;
  static constexpr TerminalAction RELEASE =
    TerminalActionRequest_TerminalAction_RELEASE;
  static constexpr TerminalAction CONNECT =
    TerminalActionRequest_TerminalAction_CONNECT;
  static inline bool TerminalAction_IsValid(int value) {
    return TerminalActionRequest_TerminalAction_IsValid(value);
  }
  static constexpr TerminalAction TerminalAction_MIN =
    TerminalActionRequest_TerminalAction_TerminalAction_MIN;
  static constexpr TerminalAction TerminalAction_MAX =
    TerminalActionRequest_TerminalAction_TerminalAction_MAX;
  static constexpr int TerminalAction_ARRAYSIZE =
    TerminalActionRequest_TerminalAction_TerminalAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TerminalAction_descriptor() {
    return TerminalActionRequest_TerminalAction_descriptor();
  }
  template<typename T>
  static inline const std::string& TerminalAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TerminalAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TerminalAction_Name.");
    return TerminalActionRequest_TerminalAction_Name(enum_t_value);
  }
  static inline bool TerminalAction_Parse(const std::string& name,
      TerminalAction* value) {
    return TerminalActionRequest_TerminalAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // .winfiolAxeMed.TerminalActionRequest.TerminalAction action = 2;
  void clear_action();
  ::winfiolAxeMed::TerminalActionRequest_TerminalAction action() const;
  void set_action(::winfiolAxeMed::TerminalActionRequest_TerminalAction value);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.TerminalActionRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class GenericRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.GenericRequest) */ {
 public:
  GenericRequest();
  virtual ~GenericRequest();

  GenericRequest(const GenericRequest& from);
  GenericRequest(GenericRequest&& from) noexcept
    : GenericRequest() {
    *this = ::std::move(from);
  }

  inline GenericRequest& operator=(const GenericRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericRequest& operator=(GenericRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericRequest* internal_default_instance() {
    return reinterpret_cast<const GenericRequest*>(
               &_GenericRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GenericRequest& a, GenericRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericRequest* New() const final {
    return CreateMaybeMessage<GenericRequest>(nullptr);
  }

  GenericRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericRequest& from);
  void MergeFrom(const GenericRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.GenericRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.GenericRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// -------------------------------------------------------------------

class GenericResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:winfiolAxeMed.GenericResponse) */ {
 public:
  GenericResponse();
  virtual ~GenericResponse();

  GenericResponse(const GenericResponse& from);
  GenericResponse(GenericResponse&& from) noexcept
    : GenericResponse() {
    *this = ::std::move(from);
  }

  inline GenericResponse& operator=(const GenericResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericResponse& operator=(GenericResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericResponse* internal_default_instance() {
    return reinterpret_cast<const GenericResponse*>(
               &_GenericResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GenericResponse& a, GenericResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericResponse* New() const final {
    return CreateMaybeMessage<GenericResponse>(nullptr);
  }

  GenericResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericResponse& from);
  void MergeFrom(const GenericResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "winfiolAxeMed.GenericResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_winfiolAxeMed_2eproto);
    return ::descriptor_table_winfiolAxeMed_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:winfiolAxeMed.GenericResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_winfiolAxeMed_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SessionRequest

// string clientName = 1;
inline void SessionRequest::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionRequest::clientname() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.SessionRequest.clientName)
  return clientname_.GetNoArena();
}
inline void SessionRequest::set_clientname(const std::string& value) {
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.SessionRequest.clientName)
}
inline void SessionRequest::set_clientname(std::string&& value) {
  
  clientname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.SessionRequest.clientName)
}
inline void SessionRequest::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.SessionRequest.clientName)
}
inline void SessionRequest::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.SessionRequest.clientName)
}
inline std::string* SessionRequest::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.SessionRequest.clientName)
  return clientname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.SessionRequest.clientName)
  
  return clientname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionRequest::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.SessionRequest.clientName)
}

// string enmUserId = 2;
inline void SessionRequest::clear_enmuserid() {
  enmuserid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionRequest::enmuserid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.SessionRequest.enmUserId)
  return enmuserid_.GetNoArena();
}
inline void SessionRequest::set_enmuserid(const std::string& value) {
  
  enmuserid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.SessionRequest.enmUserId)
}
inline void SessionRequest::set_enmuserid(std::string&& value) {
  
  enmuserid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.SessionRequest.enmUserId)
}
inline void SessionRequest::set_enmuserid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  enmuserid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.SessionRequest.enmUserId)
}
inline void SessionRequest::set_enmuserid(const char* value, size_t size) {
  
  enmuserid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.SessionRequest.enmUserId)
}
inline std::string* SessionRequest::mutable_enmuserid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.SessionRequest.enmUserId)
  return enmuserid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionRequest::release_enmuserid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.SessionRequest.enmUserId)
  
  return enmuserid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionRequest::set_allocated_enmuserid(std::string* enmuserid) {
  if (enmuserid != nullptr) {
    
  } else {
    
  }
  enmuserid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enmuserid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.SessionRequest.enmUserId)
}

// -------------------------------------------------------------------

// SessionResponse

// string sessionId = 1;
inline void SessionResponse::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SessionResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.SessionResponse.sessionId)
  return sessionid_.GetNoArena();
}
inline void SessionResponse::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.SessionResponse.sessionId)
}
inline void SessionResponse::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.SessionResponse.sessionId)
}
inline void SessionResponse::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.SessionResponse.sessionId)
}
inline void SessionResponse::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.SessionResponse.sessionId)
}
inline std::string* SessionResponse::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.SessionResponse.sessionId)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SessionResponse::release_sessionid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.SessionResponse.sessionId)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SessionResponse::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.SessionResponse.sessionId)
}

// -------------------------------------------------------------------

// ConnectRequest

// string sessionId = 1;
inline void ConnectRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnectRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.ConnectRequest.sessionId)
  return sessionid_.GetNoArena();
}
inline void ConnectRequest::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.ConnectRequest.sessionId)
}
inline void ConnectRequest::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.ConnectRequest.sessionId)
}
inline void ConnectRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.ConnectRequest.sessionId)
}
inline void ConnectRequest::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.ConnectRequest.sessionId)
}
inline std::string* ConnectRequest::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.ConnectRequest.sessionId)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnectRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.ConnectRequest.sessionId)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.ConnectRequest.sessionId)
}

// string neId = 2;
inline void ConnectRequest::clear_neid() {
  neid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnectRequest::neid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.ConnectRequest.neId)
  return neid_.GetNoArena();
}
inline void ConnectRequest::set_neid(const std::string& value) {
  
  neid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.ConnectRequest.neId)
}
inline void ConnectRequest::set_neid(std::string&& value) {
  
  neid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.ConnectRequest.neId)
}
inline void ConnectRequest::set_neid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  neid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.ConnectRequest.neId)
}
inline void ConnectRequest::set_neid(const char* value, size_t size) {
  
  neid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.ConnectRequest.neId)
}
inline std::string* ConnectRequest::mutable_neid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.ConnectRequest.neId)
  return neid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnectRequest::release_neid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.ConnectRequest.neId)
  
  return neid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectRequest::set_allocated_neid(std::string* neid) {
  if (neid != nullptr) {
    
  } else {
    
  }
  neid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), neid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.ConnectRequest.neId)
}

// .winfiolAxeMed.ConnectRequest.ApNodeSide nodeSide = 3;
inline void ConnectRequest::clear_nodeside() {
  nodeside_ = 0;
}
inline ::winfiolAxeMed::ConnectRequest_ApNodeSide ConnectRequest::nodeside() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.ConnectRequest.nodeSide)
  return static_cast< ::winfiolAxeMed::ConnectRequest_ApNodeSide >(nodeside_);
}
inline void ConnectRequest::set_nodeside(::winfiolAxeMed::ConnectRequest_ApNodeSide value) {
  
  nodeside_ = value;
  // @@protoc_insertion_point(field_set:winfiolAxeMed.ConnectRequest.nodeSide)
}

// string username = 4;
inline void ConnectRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnectRequest::username() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.ConnectRequest.username)
  return username_.GetNoArena();
}
inline void ConnectRequest::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.ConnectRequest.username)
}
inline void ConnectRequest::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.ConnectRequest.username)
}
inline void ConnectRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.ConnectRequest.username)
}
inline void ConnectRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.ConnectRequest.username)
}
inline std::string* ConnectRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.ConnectRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnectRequest::release_username() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.ConnectRequest.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.ConnectRequest.username)
}

// string password = 5;
inline void ConnectRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConnectRequest::password() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.ConnectRequest.password)
  return password_.GetNoArena();
}
inline void ConnectRequest::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.ConnectRequest.password)
}
inline void ConnectRequest::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.ConnectRequest.password)
}
inline void ConnectRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.ConnectRequest.password)
}
inline void ConnectRequest::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.ConnectRequest.password)
}
inline std::string* ConnectRequest::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.ConnectRequest.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConnectRequest::release_password() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.ConnectRequest.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.ConnectRequest.password)
}

// .winfiolAxeMed.ConnectRequest.ApNode node = 6;
inline void ConnectRequest::clear_node() {
  node_ = 0;
}
inline ::winfiolAxeMed::ConnectRequest_ApNode ConnectRequest::node() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.ConnectRequest.node)
  return static_cast< ::winfiolAxeMed::ConnectRequest_ApNode >(node_);
}
inline void ConnectRequest::set_node(::winfiolAxeMed::ConnectRequest_ApNode value) {
  
  node_ = value;
  // @@protoc_insertion_point(field_set:winfiolAxeMed.ConnectRequest.node)
}

// -------------------------------------------------------------------

// CommandRequest

// string sessionId = 1;
inline void CommandRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CommandRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.CommandRequest.sessionId)
  return sessionid_.GetNoArena();
}
inline void CommandRequest::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.CommandRequest.sessionId)
}
inline void CommandRequest::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.CommandRequest.sessionId)
}
inline void CommandRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.CommandRequest.sessionId)
}
inline void CommandRequest::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.CommandRequest.sessionId)
}
inline std::string* CommandRequest::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.CommandRequest.sessionId)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommandRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.CommandRequest.sessionId)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommandRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.CommandRequest.sessionId)
}

// string cmdInput = 2;
inline void CommandRequest::clear_cmdinput() {
  cmdinput_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CommandRequest::cmdinput() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.CommandRequest.cmdInput)
  return cmdinput_.GetNoArena();
}
inline void CommandRequest::set_cmdinput(const std::string& value) {
  
  cmdinput_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.CommandRequest.cmdInput)
}
inline void CommandRequest::set_cmdinput(std::string&& value) {
  
  cmdinput_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.CommandRequest.cmdInput)
}
inline void CommandRequest::set_cmdinput(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cmdinput_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.CommandRequest.cmdInput)
}
inline void CommandRequest::set_cmdinput(const char* value, size_t size) {
  
  cmdinput_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.CommandRequest.cmdInput)
}
inline std::string* CommandRequest::mutable_cmdinput() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.CommandRequest.cmdInput)
  return cmdinput_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommandRequest::release_cmdinput() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.CommandRequest.cmdInput)
  
  return cmdinput_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommandRequest::set_allocated_cmdinput(std::string* cmdinput) {
  if (cmdinput != nullptr) {
    
  } else {
    
  }
  cmdinput_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmdinput);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.CommandRequest.cmdInput)
}

// string cmdType = 3;
inline void CommandRequest::clear_cmdtype() {
  cmdtype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CommandRequest::cmdtype() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.CommandRequest.cmdType)
  return cmdtype_.GetNoArena();
}
inline void CommandRequest::set_cmdtype(const std::string& value) {
  
  cmdtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.CommandRequest.cmdType)
}
inline void CommandRequest::set_cmdtype(std::string&& value) {
  
  cmdtype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.CommandRequest.cmdType)
}
inline void CommandRequest::set_cmdtype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cmdtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.CommandRequest.cmdType)
}
inline void CommandRequest::set_cmdtype(const char* value, size_t size) {
  
  cmdtype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.CommandRequest.cmdType)
}
inline std::string* CommandRequest::mutable_cmdtype() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.CommandRequest.cmdType)
  return cmdtype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommandRequest::release_cmdtype() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.CommandRequest.cmdType)
  
  return cmdtype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommandRequest::set_allocated_cmdtype(std::string* cmdtype) {
  if (cmdtype != nullptr) {
    
  } else {
    
  }
  cmdtype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmdtype);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.CommandRequest.cmdType)
}

// string cpName = 4;
inline void CommandRequest::clear_cpname() {
  cpname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CommandRequest::cpname() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.CommandRequest.cpName)
  return cpname_.GetNoArena();
}
inline void CommandRequest::set_cpname(const std::string& value) {
  
  cpname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.CommandRequest.cpName)
}
inline void CommandRequest::set_cpname(std::string&& value) {
  
  cpname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.CommandRequest.cpName)
}
inline void CommandRequest::set_cpname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cpname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.CommandRequest.cpName)
}
inline void CommandRequest::set_cpname(const char* value, size_t size) {
  
  cpname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.CommandRequest.cpName)
}
inline std::string* CommandRequest::mutable_cpname() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.CommandRequest.cpName)
  return cpname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommandRequest::release_cpname() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.CommandRequest.cpName)
  
  return cpname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommandRequest::set_allocated_cpname(std::string* cpname) {
  if (cpname != nullptr) {
    
  } else {
    
  }
  cpname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpname);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.CommandRequest.cpName)
}

// -------------------------------------------------------------------

// CommandResponse

// string cmdOutput = 1;
inline void CommandResponse::clear_cmdoutput() {
  cmdoutput_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CommandResponse::cmdoutput() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.CommandResponse.cmdOutput)
  return cmdoutput_.GetNoArena();
}
inline void CommandResponse::set_cmdoutput(const std::string& value) {
  
  cmdoutput_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.CommandResponse.cmdOutput)
}
inline void CommandResponse::set_cmdoutput(std::string&& value) {
  
  cmdoutput_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.CommandResponse.cmdOutput)
}
inline void CommandResponse::set_cmdoutput(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cmdoutput_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.CommandResponse.cmdOutput)
}
inline void CommandResponse::set_cmdoutput(const char* value, size_t size) {
  
  cmdoutput_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.CommandResponse.cmdOutput)
}
inline std::string* CommandResponse::mutable_cmdoutput() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.CommandResponse.cmdOutput)
  return cmdoutput_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommandResponse::release_cmdoutput() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.CommandResponse.cmdOutput)
  
  return cmdoutput_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommandResponse::set_allocated_cmdoutput(std::string* cmdoutput) {
  if (cmdoutput != nullptr) {
    
  } else {
    
  }
  cmdoutput_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cmdoutput);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.CommandResponse.cmdOutput)
}

// -------------------------------------------------------------------

// StreamMessage

// string sessionId = 1;
inline void StreamMessage::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StreamMessage::sessionid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.StreamMessage.sessionId)
  return sessionid_.GetNoArena();
}
inline void StreamMessage::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.StreamMessage.sessionId)
}
inline void StreamMessage::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.StreamMessage.sessionId)
}
inline void StreamMessage::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.StreamMessage.sessionId)
}
inline void StreamMessage::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.StreamMessage.sessionId)
}
inline std::string* StreamMessage::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.StreamMessage.sessionId)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamMessage::release_sessionid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.StreamMessage.sessionId)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamMessage::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.StreamMessage.sessionId)
}

// .winfiolAxeMed.StreamMessage.MessageType type = 2;
inline void StreamMessage::clear_type() {
  type_ = 0;
}
inline ::winfiolAxeMed::StreamMessage_MessageType StreamMessage::type() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.StreamMessage.type)
  return static_cast< ::winfiolAxeMed::StreamMessage_MessageType >(type_);
}
inline void StreamMessage::set_type(::winfiolAxeMed::StreamMessage_MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:winfiolAxeMed.StreamMessage.type)
}

// string message = 3;
inline void StreamMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StreamMessage::message() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.StreamMessage.message)
  return message_.GetNoArena();
}
inline void StreamMessage::set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.StreamMessage.message)
}
inline void StreamMessage::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.StreamMessage.message)
}
inline void StreamMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.StreamMessage.message)
}
inline void StreamMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.StreamMessage.message)
}
inline std::string* StreamMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.StreamMessage.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamMessage::release_message() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.StreamMessage.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.StreamMessage.message)
}

// -------------------------------------------------------------------

// TerminalActionRequest

// string sessionId = 1;
inline void TerminalActionRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TerminalActionRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.TerminalActionRequest.sessionId)
  return sessionid_.GetNoArena();
}
inline void TerminalActionRequest::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.TerminalActionRequest.sessionId)
}
inline void TerminalActionRequest::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.TerminalActionRequest.sessionId)
}
inline void TerminalActionRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.TerminalActionRequest.sessionId)
}
inline void TerminalActionRequest::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.TerminalActionRequest.sessionId)
}
inline std::string* TerminalActionRequest::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.TerminalActionRequest.sessionId)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TerminalActionRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.TerminalActionRequest.sessionId)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TerminalActionRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.TerminalActionRequest.sessionId)
}

// .winfiolAxeMed.TerminalActionRequest.TerminalAction action = 2;
inline void TerminalActionRequest::clear_action() {
  action_ = 0;
}
inline ::winfiolAxeMed::TerminalActionRequest_TerminalAction TerminalActionRequest::action() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.TerminalActionRequest.action)
  return static_cast< ::winfiolAxeMed::TerminalActionRequest_TerminalAction >(action_);
}
inline void TerminalActionRequest::set_action(::winfiolAxeMed::TerminalActionRequest_TerminalAction value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:winfiolAxeMed.TerminalActionRequest.action)
}

// -------------------------------------------------------------------

// GenericRequest

// string sessionId = 1;
inline void GenericRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GenericRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.GenericRequest.sessionId)
  return sessionid_.GetNoArena();
}
inline void GenericRequest::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:winfiolAxeMed.GenericRequest.sessionId)
}
inline void GenericRequest::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:winfiolAxeMed.GenericRequest.sessionId)
}
inline void GenericRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:winfiolAxeMed.GenericRequest.sessionId)
}
inline void GenericRequest::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:winfiolAxeMed.GenericRequest.sessionId)
}
inline std::string* GenericRequest::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:winfiolAxeMed.GenericRequest.sessionId)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GenericRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:winfiolAxeMed.GenericRequest.sessionId)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GenericRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:winfiolAxeMed.GenericRequest.sessionId)
}

// -------------------------------------------------------------------

// GenericResponse

// int32 status = 1;
inline void GenericResponse::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenericResponse::status() const {
  // @@protoc_insertion_point(field_get:winfiolAxeMed.GenericResponse.status)
  return status_;
}
inline void GenericResponse::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:winfiolAxeMed.GenericResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace winfiolAxeMed

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::winfiolAxeMed::ConnectRequest_ApNodeSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::winfiolAxeMed::ConnectRequest_ApNodeSide>() {
  return ::winfiolAxeMed::ConnectRequest_ApNodeSide_descriptor();
}
template <> struct is_proto_enum< ::winfiolAxeMed::ConnectRequest_ApNode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::winfiolAxeMed::ConnectRequest_ApNode>() {
  return ::winfiolAxeMed::ConnectRequest_ApNode_descriptor();
}
template <> struct is_proto_enum< ::winfiolAxeMed::StreamMessage_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::winfiolAxeMed::StreamMessage_MessageType>() {
  return ::winfiolAxeMed::StreamMessage_MessageType_descriptor();
}
template <> struct is_proto_enum< ::winfiolAxeMed::TerminalActionRequest_TerminalAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::winfiolAxeMed::TerminalActionRequest_TerminalAction>() {
  return ::winfiolAxeMed::TerminalActionRequest_TerminalAction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_winfiolAxeMed_2eproto
